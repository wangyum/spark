== Physical Plan ==
* HashAggregate (25)
+- Exchange (24)
   +- * HashAggregate (23)
      +- * Project (22)
         +- * BroadcastHashJoin Inner BuildRight (21)
            :- * HashAggregate (11)
            :  +- * Project (10)
            :     +- * BroadcastHashJoin Inner BuildRight (9)
            :        :- * Filter (3)
            :        :  +- * ColumnarToRow (2)
            :        :     +- Scan parquet default.lineitem (1)
            :        +- BroadcastExchange (8)
            :           +- * Project (7)
            :              +- * Filter (6)
            :                 +- * ColumnarToRow (5)
            :                    +- Scan parquet default.part (4)
            +- BroadcastExchange (20)
               +- * HashAggregate (19)
                  +- * Filter (18)
                     +- * HashAggregate (17)
                        +- Exchange (16)
                           +- * HashAggregate (15)
                              +- * Filter (14)
                                 +- * ColumnarToRow (13)
                                    +- Scan parquet default.lineitem (12)


(1) Scan parquet default.lineitem
Output [3]: [l_partkey#1, l_quantity#2, l_extendedprice#3]
Batched: true
Location [not included in comparison]/{warehouse_dir}/lineitem]
PushedFilters: [IsNotNull(l_partkey), IsNotNull(l_quantity)]
ReadSchema: struct<l_partkey:bigint,l_quantity:decimal(10,0),l_extendedprice:decimal(10,0)>

(2) ColumnarToRow [codegen id : 4]
Input [3]: [l_partkey#1, l_quantity#2, l_extendedprice#3]

(3) Filter [codegen id : 4]
Input [3]: [l_partkey#1, l_quantity#2, l_extendedprice#3]
Condition : (isnotnull(l_partkey#1) AND isnotnull(l_quantity#2))

(4) Scan parquet default.part
Output [3]: [p_partkey#4, p_brand#5, p_container#6]
Batched: true
Location [not included in comparison]/{warehouse_dir}/part]
PushedFilters: [IsNotNull(p_brand), IsNotNull(p_container), EqualTo(p_brand,Brand#7), EqualTo(p_container,MED BOX), IsNotNull(p_partkey)]
ReadSchema: struct<p_partkey:bigint,p_brand:string,p_container:string>

(5) ColumnarToRow [codegen id : 1]
Input [3]: [p_partkey#4, p_brand#5, p_container#6]

(6) Filter [codegen id : 1]
Input [3]: [p_partkey#4, p_brand#5, p_container#6]
Condition : ((((isnotnull(p_brand#5) AND isnotnull(p_container#6)) AND (p_brand#5 = Brand#7)) AND (p_container#6 = MED BOX)) AND isnotnull(p_partkey#4))

(7) Project [codegen id : 1]
Output [1]: [p_partkey#4]
Input [3]: [p_partkey#4, p_brand#5, p_container#6]

(8) BroadcastExchange
Input [1]: [p_partkey#4]
Arguments: HashedRelationBroadcastMode(List(input[0, bigint, true]),false), [id=#8]

(9) BroadcastHashJoin [codegen id : 4]
Left keys [1]: [l_partkey#1]
Right keys [1]: [p_partkey#4]
Join condition: None

(10) Project [codegen id : 4]
Output [3]: [l_quantity#2, l_extendedprice#3, p_partkey#4]
Input [4]: [l_partkey#1, l_quantity#2, l_extendedprice#3, p_partkey#4]

(11) HashAggregate [codegen id : 4]
Input [3]: [l_quantity#2, l_extendedprice#3, p_partkey#4]
Keys [2]: [l_quantity#2, p_partkey#4]
Functions: []
Aggregate Attributes: []
Results [2]: [l_quantity#2, p_partkey#4]

(12) Scan parquet default.lineitem
Output [2]: [l_partkey#9, l_quantity#10]
Batched: true
Location [not included in comparison]/{warehouse_dir}/lineitem]
PushedFilters: [IsNotNull(l_partkey)]
ReadSchema: struct<l_partkey:bigint,l_quantity:decimal(10,0)>

(13) ColumnarToRow [codegen id : 2]
Input [2]: [l_partkey#9, l_quantity#10]

(14) Filter [codegen id : 2]
Input [2]: [l_partkey#9, l_quantity#10]
Condition : isnotnull(l_partkey#9)

(15) HashAggregate [codegen id : 2]
Input [2]: [l_partkey#9, l_quantity#10]
Keys [1]: [l_partkey#9]
Functions [1]: [partial_avg(UnscaledValue(l_quantity#10))]
Aggregate Attributes [2]: [sum#11, count#12]
Results [3]: [l_partkey#9, sum#13, count#14]

(16) Exchange
Input [3]: [l_partkey#9, sum#13, count#14]
Arguments: hashpartitioning(l_partkey#9, 5), ENSURE_REQUIREMENTS, [id=#15]

(17) HashAggregate [codegen id : 3]
Input [3]: [l_partkey#9, sum#13, count#14]
Keys [1]: [l_partkey#9]
Functions [1]: [avg(UnscaledValue(l_quantity#10))]
Aggregate Attributes [1]: [avg(UnscaledValue(l_quantity#10))#16]
Results [2]: [CheckOverflow((0.2000 * promote_precision(cast((avg(UnscaledValue(l_quantity#10))#16 / 1.0) as decimal(14,4)))), DecimalType(16,5)) AS (0.2 * avg(l_quantity))#17, l_partkey#9]

(18) Filter [codegen id : 3]
Input [2]: [(0.2 * avg(l_quantity))#17, l_partkey#9]
Condition : isnotnull((0.2 * avg(l_quantity))#17)

(19) HashAggregate [codegen id : 3]
Input [2]: [(0.2 * avg(l_quantity))#17, l_partkey#9]
Keys [2]: [(0.2 * avg(l_quantity))#17, l_partkey#9]
Functions: []
Aggregate Attributes: []
Results [2]: [(0.2 * avg(l_quantity))#17, l_partkey#9]

(20) BroadcastExchange
Input [2]: [(0.2 * avg(l_quantity))#17, l_partkey#9]
Arguments: HashedRelationBroadcastMode(List(input[1, bigint, true]),false), [id=#18]

(21) BroadcastHashJoin [codegen id : 4]
Left keys [1]: [p_partkey#4]
Right keys [1]: [l_partkey#9]
Join condition: (cast(l_quantity#2 as decimal(16,5)) < (0.2 * avg(l_quantity))#17)

(22) Project [codegen id : 4]
Output: []
Input [4]: [l_quantity#2, p_partkey#4, (0.2 * avg(l_quantity))#17, l_partkey#9]

(23) HashAggregate [codegen id : 4]
Input: []
Keys: []
Functions [1]: [partial_sum(l_extendedprice#3)]
Aggregate Attributes [2]: [sum#19, isEmpty#20]
Results [2]: [sum#21, isEmpty#22]

(24) Exchange
Input [2]: [sum#21, isEmpty#22]
Arguments: SinglePartition, ENSURE_REQUIREMENTS, [id=#23]

(25) HashAggregate [codegen id : 5]
Input [2]: [sum#21, isEmpty#22]
Keys: []
Functions [1]: [sum(l_extendedprice#3)]
Aggregate Attributes [1]: [sum(l_extendedprice#3)#24]
Results [1]: [CheckOverflow((promote_precision(cast(sum(l_extendedprice#3)#24 as decimal(21,1))) / 7.0), DecimalType(27,6)) AS avg_yearly#25]

