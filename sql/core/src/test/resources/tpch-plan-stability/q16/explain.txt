== Physical Plan ==
* Sort (24)
+- Exchange (23)
   +- * HashAggregate (22)
      +- Exchange (21)
         +- * HashAggregate (20)
            +- * HashAggregate (19)
               +- Exchange (18)
                  +- * HashAggregate (17)
                     +- * Project (16)
                        +- * BroadcastHashJoin Inner BuildRight (15)
                           :- * BroadcastHashJoin LeftAnti BuildRight (10)
                           :  :- * Filter (3)
                           :  :  +- * ColumnarToRow (2)
                           :  :     +- Scan parquet default.partsupp (1)
                           :  +- BroadcastExchange (9)
                           :     +- * HashAggregate (8)
                           :        +- * Project (7)
                           :           +- * Filter (6)
                           :              +- * ColumnarToRow (5)
                           :                 +- Scan parquet default.supplier (4)
                           +- BroadcastExchange (14)
                              +- * Filter (13)
                                 +- * ColumnarToRow (12)
                                    +- Scan parquet default.part (11)


(1) Scan parquet default.partsupp
Output [2]: [ps_partkey#1, ps_suppkey#2]
Batched: true
Location [not included in comparison]/{warehouse_dir}/partsupp]
PushedFilters: [IsNotNull(ps_partkey)]
ReadSchema: struct<ps_partkey:bigint,ps_suppkey:bigint>

(2) ColumnarToRow [codegen id : 3]
Input [2]: [ps_partkey#1, ps_suppkey#2]

(3) Filter [codegen id : 3]
Input [2]: [ps_partkey#1, ps_suppkey#2]
Condition : isnotnull(ps_partkey#1)

(4) Scan parquet default.supplier
Output [2]: [s_suppkey#3, s_comment#4]
Batched: true
Location [not included in comparison]/{warehouse_dir}/supplier]
PushedFilters: [IsNotNull(s_comment)]
ReadSchema: struct<s_suppkey:bigint,s_comment:string>

(5) ColumnarToRow [codegen id : 1]
Input [2]: [s_suppkey#3, s_comment#4]

(6) Filter [codegen id : 1]
Input [2]: [s_suppkey#3, s_comment#4]
Condition : (isnotnull(s_comment#4) AND s_comment#4 LIKE %Customer%Complaints%)

(7) Project [codegen id : 1]
Output [1]: [s_suppkey#3]
Input [2]: [s_suppkey#3, s_comment#4]

(8) HashAggregate [codegen id : 1]
Input [1]: [s_suppkey#3]
Keys [1]: [s_suppkey#3]
Functions: []
Aggregate Attributes: []
Results [1]: [s_suppkey#3]

(9) BroadcastExchange
Input [1]: [s_suppkey#3]
Arguments: HashedRelationBroadcastMode(List(input[0, bigint, true]),true), [id=#5]

(10) BroadcastHashJoin [codegen id : 3]
Left keys [1]: [ps_suppkey#2]
Right keys [1]: [s_suppkey#3]
Join condition: None

(11) Scan parquet default.part
Output [4]: [p_partkey#6, p_brand#7, p_type#8, p_size#9]
Batched: true
Location [not included in comparison]/{warehouse_dir}/part]
PushedFilters: [IsNotNull(p_brand), IsNotNull(p_type), Not(EqualTo(p_brand,Brand#10)), Not(StringStartsWith(p_type,MEDIUM POLISHED)), In(p_size, [14,19,23,3,36,45,49,9]), IsNotNull(p_partkey)]
ReadSchema: struct<p_partkey:bigint,p_brand:string,p_type:string,p_size:int>

(12) ColumnarToRow [codegen id : 2]
Input [4]: [p_partkey#6, p_brand#7, p_type#8, p_size#9]

(13) Filter [codegen id : 2]
Input [4]: [p_partkey#6, p_brand#7, p_type#8, p_size#9]
Condition : (((((isnotnull(p_brand#7) AND isnotnull(p_type#8)) AND NOT (p_brand#7 = Brand#10)) AND NOT StartsWith(p_type#8, MEDIUM POLISHED)) AND p_size#9 IN (49,14,23,45,19,3,36,9)) AND isnotnull(p_partkey#6))

(14) BroadcastExchange
Input [4]: [p_partkey#6, p_brand#7, p_type#8, p_size#9]
Arguments: HashedRelationBroadcastMode(List(input[0, bigint, false]),false), [id=#11]

(15) BroadcastHashJoin [codegen id : 3]
Left keys [1]: [ps_partkey#1]
Right keys [1]: [p_partkey#6]
Join condition: None

(16) Project [codegen id : 3]
Output [4]: [ps_suppkey#2, p_brand#7, p_type#8, p_size#9]
Input [6]: [ps_partkey#1, ps_suppkey#2, p_partkey#6, p_brand#7, p_type#8, p_size#9]

(17) HashAggregate [codegen id : 3]
Input [4]: [ps_suppkey#2, p_brand#7, p_type#8, p_size#9]
Keys [4]: [p_brand#7, p_type#8, p_size#9, ps_suppkey#2]
Functions: []
Aggregate Attributes: []
Results [4]: [p_brand#7, p_type#8, p_size#9, ps_suppkey#2]

(18) Exchange
Input [4]: [p_brand#7, p_type#8, p_size#9, ps_suppkey#2]
Arguments: hashpartitioning(p_brand#7, p_type#8, p_size#9, ps_suppkey#2, 5), ENSURE_REQUIREMENTS, [id=#12]

(19) HashAggregate [codegen id : 4]
Input [4]: [p_brand#7, p_type#8, p_size#9, ps_suppkey#2]
Keys [4]: [p_brand#7, p_type#8, p_size#9, ps_suppkey#2]
Functions: []
Aggregate Attributes: []
Results [4]: [p_brand#7, p_type#8, p_size#9, ps_suppkey#2]

(20) HashAggregate [codegen id : 4]
Input [4]: [p_brand#7, p_type#8, p_size#9, ps_suppkey#2]
Keys [3]: [p_brand#7, p_type#8, p_size#9]
Functions [1]: [partial_count(distinct ps_suppkey#2)]
Aggregate Attributes [1]: [count(ps_suppkey#2)#13]
Results [4]: [p_brand#7, p_type#8, p_size#9, count#14]

(21) Exchange
Input [4]: [p_brand#7, p_type#8, p_size#9, count#14]
Arguments: hashpartitioning(p_brand#7, p_type#8, p_size#9, 5), ENSURE_REQUIREMENTS, [id=#15]

(22) HashAggregate [codegen id : 5]
Input [4]: [p_brand#7, p_type#8, p_size#9, count#14]
Keys [3]: [p_brand#7, p_type#8, p_size#9]
Functions [1]: [count(distinct ps_suppkey#2)]
Aggregate Attributes [1]: [count(ps_suppkey#2)#13]
Results [4]: [p_brand#7, p_type#8, p_size#9, count(ps_suppkey#2)#13 AS supplier_cnt#16]

(23) Exchange
Input [4]: [p_brand#7, p_type#8, p_size#9, supplier_cnt#16]
Arguments: rangepartitioning(supplier_cnt#16 DESC NULLS LAST, p_brand#7 ASC NULLS FIRST, p_type#8 ASC NULLS FIRST, p_size#9 ASC NULLS FIRST, 5), ENSURE_REQUIREMENTS, [id=#17]

(24) Sort [codegen id : 6]
Input [4]: [p_brand#7, p_type#8, p_size#9, supplier_cnt#16]
Arguments: [supplier_cnt#16 DESC NULLS LAST, p_brand#7 ASC NULLS FIRST, p_type#8 ASC NULLS FIRST, p_size#9 ASC NULLS FIRST], true, 0

